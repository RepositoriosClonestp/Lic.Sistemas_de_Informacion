ExplicaciÃ³n del diseÃ±o SQL

El siguiente script implementa un sistema de gestiÃ³n de proyectos siguiendo principios de normalizaciÃ³n, consistencia y buenas prÃ¡cticas de SQL Server. A continuaciÃ³n, se explica la razÃ³n de cada tabla, restricciÃ³n y decisiÃ³n de diseÃ±o.

1. CatÃ¡logos (tablas de tipificaciÃ³n)

Se crearon tablas de catÃ¡logo (roles, estados_tarea) para evitar duplicaciÃ³n de datos y errores de escritura.

Ejemplo: en vez de escribir â€œpendiente / Pendiente / PENDIENTEâ€ en cada tarea, se guarda un nÃºmero (estado_id) que apunta al catÃ¡logo estados_tarea.

Esto asegura consistencia y evita redundancia.

CREATE TABLE roles (
  rol_id INT NOT NULL,
  nombre VARCHAR(50) NOT NULL,
  CONSTRAINT PK_roles PRIMARY KEY (rol_id),
  CONSTRAINT UQ_roles_nombre UNIQUE (nombre)
);


ğŸ“Œ AquÃ­ se define:

PK_roles: clave primaria.

UQ_roles_nombre: evita nombres de roles duplicados.

2. Empleados y Proyectos

Los empleados y proyectos son entidades fuertes.

Empleados: se registran con nombre y correo electrÃ³nico. El correo es Ãºnico para evitar duplicados.

Proyectos: tienen nombre, fecha de inicio y fecha de fin opcional.

CREATE TABLE empleados (
  empleado_id INT NOT NULL,
  nombre VARCHAR(100) NOT NULL,
  correo VARCHAR(100) NOT NULL,
  CONSTRAINT PK_empleados PRIMARY KEY (empleado_id),
  CONSTRAINT UQ_empleados_correo UNIQUE (correo)
);


ğŸ“Œ JustificaciÃ³n:

UQ_empleados_correo: un mismo correo no puede repetirse en la base.

Evita registrar a la misma persona dos veces con correos idÃ©nticos.

CREATE TABLE proyectos (
  proyecto_id INT NOT NULL,
  nombre VARCHAR(120) NOT NULL,
  fecha_inicio DATE NOT NULL,
  fecha_fin DATE NULL,
  CONSTRAINT PK_proyectos PRIMARY KEY (proyecto_id),
  CONSTRAINT UQ_proyectos_nombre UNIQUE (nombre),
  CONSTRAINT CK_proyectos_fechas CHECK (fecha_fin IS NULL OR fecha_fin >= fecha_inicio)
);


ğŸ“Œ JustificaciÃ³n:

UQ_proyectos_nombre: no puede haber dos proyectos con el mismo nombre.

CK_proyectos_fechas: garantiza que la fecha de fin sea mayor o igual a la fecha de inicio (o nula si aÃºn sigue activo).

3. Asignaciones (relaciÃ³n M:N)

Un empleado puede estar en varios proyectos, y cada proyecto tiene varios empleados.

Para resolver esta relaciÃ³n M:N, se usa la tabla asignaciones.

AdemÃ¡s, se incluye el rol de cada empleado dentro del proyecto.

CREATE TABLE asignaciones (
  proyecto_id INT NOT NULL,
  empleado_id INT NOT NULL,
  rol_id INT NOT NULL,
  fecha_inicio DATE NOT NULL,
  fecha_fin DATE NULL,
  CONSTRAINT PK_asignaciones PRIMARY KEY (proyecto_id, empleado_id),
  CONSTRAINT FK_asig_proyectos FOREIGN KEY (proyecto_id) REFERENCES proyectos(proyecto_id),
  CONSTRAINT FK_asig_empleados FOREIGN KEY (empleado_id) REFERENCES empleados(empleado_id),
  CONSTRAINT FK_asig_roles FOREIGN KEY (rol_id) REFERENCES roles(rol_id),
  CONSTRAINT CK_asig_fechas CHECK (fecha_fin IS NULL OR fecha_fin >= fecha_inicio)
);


ğŸ“Œ JustificaciÃ³n:

PK_asignaciones: evita que un mismo empleado se repita en el mismo proyecto.

FK_asig_roles: asegura que el rol existe en la tabla roles.

CK_asig_fechas: mantiene coherencia temporal (la fecha de fin debe ser posterior).

4. Tareas (relaciÃ³n 1:N dentro de un proyecto)

Cada proyecto se descompone en tareas.

Las tareas tienen descripciÃ³n, fechas y estado.

Se identifican dentro del proyecto por un nÃºmero de orden.

CREATE TABLE tareas (
  tarea_id INT NOT NULL,
  proyecto_id INT NOT NULL,
  orden INT NOT NULL,
  descripcion VARCHAR(300) NOT NULL,
  fecha_inicio DATE NOT NULL,
  fecha_fin DATE NULL,
  estado_id INT NOT NULL,
  CONSTRAINT PK_tareas PRIMARY KEY (tarea_id),
  CONSTRAINT FK_tareas_proyectos FOREIGN KEY (proyecto_id) REFERENCES proyectos(proyecto_id),
  CONSTRAINT FK_tareas_estado FOREIGN KEY (estado_id) REFERENCES estados_tarea(estado_id),
  CONSTRAINT UQ_tareas_orden_x_proy UNIQUE (proyecto_id, orden),
  CONSTRAINT CK_tareas_orden_pos CHECK (orden > 0),
  CONSTRAINT CK_tareas_fechas CHECK (fecha_fin IS NULL OR fecha_fin >= fecha_inicio)
);


ğŸ“Œ JustificaciÃ³n:

UQ_tareas_orden_x_proy: dentro de un proyecto, el nÃºmero de orden no se puede repetir.

CK_tareas_orden_pos: garantiza que el orden sea positivo.

FK_tareas_estado: obliga a que cada tarea tenga un estado vÃ¡lido del catÃ¡logo.

5. Restricciones de integridad

El diseÃ±o incluye distintos tipos de restricciones:

PRIMARY KEY: asegura unicidad en cada tabla.

FOREIGN KEY: mantiene integridad referencial.

UNIQUE: evita datos duplicados.

CHECK: valida condiciones lÃ³gicas.

DEFAULT: asigna valores iniciales, como estado â€œpendienteâ€ en tareas nuevas.

Ejemplo de DEFAULT:

ALTER TABLE tareas
  ADD CONSTRAINT DF_tareas_estado DEFAULT (1) FOR estado_id;


ğŸ“Œ Esto asigna automÃ¡ticamente el estado â€œpendienteâ€ a las nuevas tareas si no se especifica otro.

6. Pruebas de restricciones

Para validar el diseÃ±o, se insertaron datos que generan errores controlados:

Insertar un correo repetido en empleados â†’ viola UQ_empleados_correo.

Insertar una tarea con orden negativo â†’ viola CK_tareas_orden_pos.

Intentar asignar dos veces el mismo empleado al mismo proyecto â†’ viola PK_asignaciones.

ğŸ‘‰ Esto demuestra que la base de datos se protege sola de inconsistencias, sin depender Ãºnicamente de la aplicaciÃ³n.

ConclusiÃ³n

El modelo cumple con:

NormalizaciÃ³n hasta 3FN (sin redundancias).

Integridad referencial (PK y FK bien definidas).

Consistencia lÃ³gica (CHECK, UNIQUE, DEFAULT).

Buenas prÃ¡cticas en SQL Server (snake_case, tipos de datos adecuados, NULL vs NOT NULL).

Gracias a esto, el sistema garantiza informaciÃ³n confiable, ordenada y fÃ¡cil de mantener.